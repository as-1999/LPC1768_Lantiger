; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--debug -c --asm --interleave -o.\Obj\_fs_flashio.o --depend=.\Obj\_fs_flashio.d --cpu=Cortex-M3 --apcs=interwork -O3 -I.\FlashFS -Id:\Keil\ARM\INC -Id:\Keil\ARM\INC\NXP\LPC17xx --omf_browse=.\Obj\_fs_flashio.crf FlashFS\_fs_FlashIO.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  fs_rd_alloc PROC
;;;415    
;;;416    U32 fs_rd_alloc (U32 adr, FALLOC *fa) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;417      U32 *pa;
;;;418    
;;;419      if (adr & 0x01) {
000004  07c0              LSLS     r0,r0,#31
000006  d006              BEQ      |L1.22|
;;;420        /* SPI Flash access. */
;;;421        fs_spi_ReadData ((adr & ~1), 8, (U8 *)fa);
000008  460a              MOV      r2,r1
00000a  f0240001          BIC      r0,r4,#1
00000e  2108              MOVS     r1,#8
000010  f7fffffe          BL       fs_spi_ReadData
000014  e003              B        |L1.30|
                  |L1.22|
;;;422      }
;;;423      else {
;;;424        /* Embedded Flash/RAM access. */
;;;425        pa = (U32 *)fa;
;;;426        pa[0] = MVAR (U32, adr);
000016  6820              LDR      r0,[r4,#0]
;;;427        pa[1] = MVAR (U32, adr+4);
000018  6008              STR      r0,[r1,#0]
00001a  6860              LDR      r0,[r4,#4]
00001c  6048              STR      r0,[r1,#4]
                  |L1.30|
;;;428      }
;;;429      return (adr - 8);
00001e  f1a40008          SUB      r0,r4,#8
;;;430    }
000022  bd10              POP      {r4,pc}
;;;431    
                          ENDP

                  fs_adr_sig PROC
;;;396    
;;;397    U32 fs_adr_sig (U32 bl, IOB *fcb) {
000024  2304              MOVS     r3,#4
;;;398      U32 adr;
;;;399    
;;;400      adr = (U32)((DEVCONF *)fcb->DevCfg)[bl].bEnd;
000026  68ca              LDR      r2,[r1,#0xc]
000028  eb0300c0          ADD      r0,r3,r0,LSL #3
;;;401      if (fcb->drive == DRV_SPI) {
00002c  7909              LDRB     r1,[r1,#4]
00002e  5810              LDR      r0,[r2,r0]            ;400
000030  2902              CMP      r1,#2
000032  d101              BNE      |L1.56|
;;;402        adr |= 0x01;
000034  f0400001          ORR      r0,r0,#1
                  |L1.56|
;;;403      }
;;;404      return (adr);
;;;405    }
000038  4770              BX       lr
;;;406    
                          ENDP

                  fs_get_freeID PROC
;;;19     
;;;20     U16 fs_get_freeID (U32 maxID, IOB *fcb) {
00003a  e92d41fc          PUSH     {r2-r8,lr}
00003e  460f              MOV      r7,r1
;;;21       FALLOC fa;
;;;22       U32 bl,fid,adr;
;;;23     
;;;24       maxID |= 0x8000;
000040  f4404600          ORR      r6,r0,#0x8000
;;;25       for (fid = 0x8001; fid < maxID;  ) {
000044  f2480401          MOV      r4,#0x8001
000048  e01a              B        |L1.128|
                  |L1.74|
;;;26         for (bl = 0; bl < fcb->NumSect; bl++) {
00004a  2500              MOVS     r5,#0
00004c  e010              B        |L1.112|
                  |L1.78|
;;;27           adr = fs_adr_sig (bl, fcb) - 8;
00004e  4639              MOV      r1,r7
000050  4628              MOV      r0,r5
000052  f7fffffe          BL       fs_adr_sig
000056  3808              SUBS     r0,r0,#8
                  |L1.88|
;;;28           for (;;) {
;;;29             adr = fs_rd_alloc (adr, &fa);
000058  4669              MOV      r1,sp
00005a  f7fffffe          BL       fs_rd_alloc
;;;30             /* If this fileID is used, go and check next one */
;;;31             if (fa.fileID == fid) goto nextfid;
00005e  f8bd1004          LDRH     r1,[sp,#4]
000062  42a1              CMP      r1,r4
000064  d00b              BEQ      |L1.126|
;;;32             if (fa.end == fcb->InitVal) break;
000066  9900              LDR      r1,[sp,#0]
000068  68ba              LDR      r2,[r7,#8]
00006a  4291              CMP      r1,r2
00006c  d1f4              BNE      |L1.88|
00006e  1c6d              ADDS     r5,r5,#1              ;26
                  |L1.112|
000070  88f8              LDRH     r0,[r7,#6]            ;26
000072  42a8              CMP      r0,r5                 ;26
000074  d8eb              BHI      |L1.78|
;;;33           }
;;;34         }
;;;35         return (fid & 0x7FFF);
000076  f3c4000e          UBFX     r0,r4,#0,#15
                  |L1.122|
;;;36     nextfid:
;;;37         fid++;
;;;38       }
;;;39       return ((maxID + 1) & 0x7FFF);
;;;40     }
00007a  e8bd81fc          POP      {r2-r8,pc}
                  |L1.126|
00007e  1c64              ADDS     r4,r4,#1              ;37
                  |L1.128|
000080  42b4              CMP      r4,r6                 ;25
000082  d3e2              BCC      |L1.74|
000084  1c76              ADDS     r6,r6,#1              ;39
000086  f3c6000e          UBFX     r0,r6,#0,#15          ;39
00008a  e7f6              B        |L1.122|
;;;41     
                          ENDP

                  fs_get_freeMem PROC
;;;48     
;;;49     U32 fs_get_freeMem (U32 block, IOB *fcb) {
00008c  b57c              PUSH     {r2-r6,lr}
00008e  4606              MOV      r6,r0
000090  460c              MOV      r4,r1
;;;50       FALLOC fa;
;;;51       U32 size,adr,prev;
;;;52     
;;;53       adr = fs_adr_sig (block, fcb) - 8;
000092  f7fffffe          BL       fs_adr_sig
000096  3808              SUBS     r0,r0,#8
;;;54       for (prev = 0; ; prev = fa.end) {
000098  2500              MOVS     r5,#0
                  |L1.154|
;;;55         adr = fs_rd_alloc (adr, &fa);
00009a  4669              MOV      r1,sp
00009c  f7fffffe          BL       fs_rd_alloc
;;;56         if (fa.end == fcb->InitVal) break;
0000a0  9900              LDR      r1,[sp,#0]
0000a2  68a2              LDR      r2,[r4,#8]
0000a4  4291              CMP      r1,r2
0000a6  d001              BEQ      |L1.172|
0000a8  460d              MOV      r5,r1                 ;54
0000aa  e7f6              B        |L1.154|
                  |L1.172|
;;;57       }
;;;58       size = (adr & ~1) + 8 - ((DEVCONF *)fcb->DevCfg)[block].bStart - prev;
0000ac  68e1              LDR      r1,[r4,#0xc]
0000ae  f0200001          BIC      r0,r0,#1
0000b2  f8511036          LDR      r1,[r1,r6,LSL #3]
0000b6  1a40              SUBS     r0,r0,r1
0000b8  1b40              SUBS     r0,r0,r5
0000ba  3008              ADDS     r0,r0,#8
;;;59       if (size < 256) {
0000bc  28ff              CMP      r0,#0xff
0000be  d800              BHI      |L1.194|
;;;60         /* This block is considered to be full. */
;;;61         return (0);
0000c0  2000              MOVS     r0,#0
                  |L1.194|
;;;62       }
;;;63       return (size);
;;;64     }
0000c2  bd7c              POP      {r2-r6,pc}
;;;65     
                          ENDP

                  fs_check_fwopen PROC
;;;74     
;;;75     BOOL fs_check_fwopen (U32 block, IOB *fcb) {
0000c4  b570              PUSH     {r4-r6,lr}
;;;76       U32 i;
;;;77     
;;;78       for (i = 0; i < _NFILE; i++) {
0000c6  2200              MOVS     r2,#0
;;;79         if (&_iob[i] == fcb) {
0000c8  4cdf              LDR      r4,|L1.1096|
0000ca  4de0              LDR      r5,|L1.1100|
0000cc  e011              B        |L1.242|
0000ce  bf00              NOP      
                  |L1.208|
0000d0  eb020382          ADD      r3,r2,r2,LSL #2
0000d4  eb0303c2          ADD      r3,r3,r2,LSL #3
0000d8  eb040383          ADD      r3,r4,r3,LSL #2
0000dc  428b              CMP      r3,r1
0000de  d007              BEQ      |L1.240|
;;;80           continue;
;;;81         }
;;;82         if ((_iob[i].flags & _IOWRT) && (_iob[i]._fblock == block)) {
0000e0  885e              LDRH     r6,[r3,#2]
0000e2  07b6              LSLS     r6,r6,#30
0000e4  d504              BPL      |L1.240|
0000e6  8a1b              LDRH     r3,[r3,#0x10]
0000e8  4283              CMP      r3,r0
0000ea  d101              BNE      |L1.240|
;;;83           /* Another File is already opened for writing in this Flash Block */
;;;84           return (__TRUE);
0000ec  2001              MOVS     r0,#1
;;;85         }
;;;86       }
;;;87       return (__FALSE);
;;;88     }
0000ee  bd70              POP      {r4-r6,pc}
                  |L1.240|
0000f0  1c52              ADDS     r2,r2,#1              ;78
                  |L1.242|
0000f2  882b              LDRH     r3,[r5,#0]            ;78  ; _NFILE
0000f4  429a              CMP      r2,r3                 ;78
0000f6  d3eb              BCC      |L1.208|
0000f8  2000              MOVS     r0,#0                 ;87
0000fa  bd70              POP      {r4-r6,pc}
;;;89     
                          ENDP

                  fs_mark_freeMem PROC
;;;95     
;;;96     void fs_mark_freeMem (IOB *fcb) {
0000fc  b57c              PUSH     {r2-r6,lr}
0000fe  4604              MOV      r4,r0
;;;97       FALLOC fa;
;;;98       U32 adr,prev;
;;;99     
;;;100      adr = fs_adr_sig (fcb->_fblock, fcb) - 8;
000100  8a00              LDRH     r0,[r0,#0x10]
000102  4621              MOV      r1,r4
000104  f7fffffe          BL       fs_adr_sig
000108  3808              SUBS     r0,r0,#8
;;;101      for (prev = 0; ; prev = fa.end) {
00010a  2500              MOVS     r5,#0
                  |L1.268|
;;;102        adr = fs_rd_alloc (adr, &fa);
00010c  4669              MOV      r1,sp
00010e  f7fffffe          BL       fs_rd_alloc
;;;103        if (fa.end == fcb->InitVal) break;
000112  9900              LDR      r1,[sp,#0]
000114  68a2              LDR      r2,[r4,#8]
000116  4291              CMP      r1,r2
000118  d001              BEQ      |L1.286|
00011a  460d              MOV      r5,r1                 ;101
00011c  e7f6              B        |L1.268|
                  |L1.286|
;;;104      }
;;;105      /* All file blocks are 4-byte aligned. */
;;;106      fcb->_fbot = (prev + 3) & ~3;
00011e  1ced              ADDS     r5,r5,#3
000120  f0250103          BIC      r1,r5,#3
;;;107      fcb->_ftop = (adr & ~1) + 8 - ((DEVCONF *)fcb->DevCfg)[fcb->_fblock].bStart;
000124  6161              STR      r1,[r4,#0x14]
000126  8a22              LDRH     r2,[r4,#0x10]
000128  68e1              LDR      r1,[r4,#0xc]
00012a  f0200001          BIC      r0,r0,#1
00012e  f8511032          LDR      r1,[r1,r2,LSL #3]
000132  1a40              SUBS     r0,r0,r1
000134  3008              ADDS     r0,r0,#8
000136  61a0              STR      r0,[r4,#0x18]
;;;108    }
000138  bd7c              POP      {r2-r6,pc}
;;;109    
                          ENDP

                  fs_rd_sig PROC
;;;440    
;;;441    U32 fs_rd_sig (U32 adr, U32 *sig) {
00013a  b510              PUSH     {r4,lr}
00013c  4604              MOV      r4,r0
;;;442    
;;;443      if (adr & 0x01) {
00013e  07c0              LSLS     r0,r0,#31
000140  d006              BEQ      |L1.336|
;;;444        /* SPI Flash access. */
;;;445        fs_spi_ReadData ((adr & ~1), 4, (U8 *)sig);
000142  460a              MOV      r2,r1
000144  f0240001          BIC      r0,r4,#1
000148  2104              MOVS     r1,#4
00014a  f7fffffe          BL       fs_spi_ReadData
00014e  e001              B        |L1.340|
                  |L1.336|
;;;446      }
;;;447      else {
;;;448        /* Embedded Flash/RAM access. */
;;;449        *sig = MVAR (U32, adr);
000150  6820              LDR      r0,[r4,#0]
000152  6008              STR      r0,[r1,#0]
                  |L1.340|
;;;450      }
;;;451      return (adr - 8);
000154  f1a40008          SUB      r0,r4,#8
;;;452    }
000158  bd10              POP      {r4,pc}
;;;453    
                          ENDP

                  fs_mark_fileMem PROC
;;;120    
;;;121    BOOL fs_mark_fileMem (IOB *fcb) {
00015a  e92d41fc          PUSH     {r2-r8,lr}
00015e  4604              MOV      r4,r0
;;;122      FALLOC fa;
;;;123      U32 i,adr,bl,prev;
;;;124    
;;;125      bl = fcb->_fblock;
000160  8a05              LDRH     r5,[r0,#0x10]
;;;126      for (i = 0; i < fcb->NumSect; i++) {
000162  2600              MOVS     r6,#0
000164  e030              B        |L1.456|
                  |L1.358|
;;;127        /* Search for file blocks identified with identification 'fileID' */
;;;128        adr = fs_adr_sig (bl, fcb);
000166  4621              MOV      r1,r4
000168  4628              MOV      r0,r5
00016a  f7fffffe          BL       fs_adr_sig
;;;129        adr = fs_rd_sig (adr, &fa.end);
00016e  4669              MOV      r1,sp
000170  f7fffffe          BL       fs_rd_sig
;;;130        if (fa.end != fcb->InitVal) {
000174  9900              LDR      r1,[sp,#0]
000176  68a2              LDR      r2,[r4,#8]
000178  4291              CMP      r1,r2
00017a  d01f              BEQ      |L1.444|
;;;131          for (prev = 0; ; prev = fa.end) {
00017c  2700              MOVS     r7,#0
                  |L1.382|
;;;132            adr = fs_rd_alloc (adr, &fa);
00017e  4669              MOV      r1,sp
000180  f7fffffe          BL       fs_rd_alloc
;;;133            if (fa.fileID == fcb->fileID && fa.index == fcb->_fidx) {
000184  f8bd1004          LDRH     r1,[sp,#4]
000188  8822              LDRH     r2,[r4,#0]
00018a  4291              CMP      r1,r2
00018c  d110              BNE      |L1.432|
00018e  f8bd1006          LDRH     r1,[sp,#6]
000192  8a62              LDRH     r2,[r4,#0x12]
000194  4291              CMP      r1,r2
000196  d10b              BNE      |L1.432|
;;;134              /* Set Current File Block parameters */ 
;;;135              fcb->_fblock = bl;
;;;136              fcb->_fbot = (prev + 3) & ~3;
000198  1cff              ADDS     r7,r7,#3
00019a  8225              STRH     r5,[r4,#0x10]         ;135
00019c  f0270003          BIC      r0,r7,#3
;;;137              fcb->_ftop = fa.end;
0001a0  6160              STR      r0,[r4,#0x14]
0001a2  9800              LDR      r0,[sp,#0]
;;;138              fcb->_fidx++; 
0001a4  61a0              STR      r0,[r4,#0x18]
0001a6  8a60              LDRH     r0,[r4,#0x12]
0001a8  1c40              ADDS     r0,r0,#1
0001aa  8260              STRH     r0,[r4,#0x12]
;;;139              return (__TRUE); 
0001ac  2001              MOVS     r0,#1
;;;140            }
;;;141            if (fa.end == fcb->InitVal) break;
;;;142          }
;;;143        }
;;;144        if (++bl == fcb->NumSect) {
;;;145          bl = 0;
;;;146        }
;;;147      }
;;;148      return (__FALSE);
;;;149    }
0001ae  e764              B        |L1.122|
                  |L1.432|
0001b0  9900              LDR      r1,[sp,#0]            ;141
0001b2  68a2              LDR      r2,[r4,#8]            ;141
0001b4  4291              CMP      r1,r2                 ;141
0001b6  d001              BEQ      |L1.444|
0001b8  460f              MOV      r7,r1                 ;131
0001ba  e7e0              B        |L1.382|
                  |L1.444|
0001bc  88e0              LDRH     r0,[r4,#6]            ;144
0001be  1c6d              ADDS     r5,r5,#1              ;144
0001c0  4285              CMP      r5,r0                 ;144
0001c2  d100              BNE      |L1.454|
0001c4  2500              MOVS     r5,#0                 ;145
                  |L1.454|
0001c6  1c76              ADDS     r6,r6,#1              ;126
                  |L1.456|
0001c8  88e0              LDRH     r0,[r4,#6]            ;126
0001ca  42b0              CMP      r0,r6                 ;126
0001cc  d8cb              BHI      |L1.358|
0001ce  2000              MOVS     r0,#0                 ;148
0001d0  e753              B        |L1.122|
;;;150    
                          ENDP

                  fs_Find_File PROC
;;;160    
;;;161    U32 fs_Find_File (const char *fname, IOB *fcb) {
0001d2  e92d4ff3          PUSH     {r0,r1,r4-r11,lr}
0001d6  b08f              SUB      sp,sp,#0x3c
0001d8  460d              MOV      r5,r1
;;;162      FALLOC fa;
;;;163      U8 buf[32];
;;;164      U32 bl,adr,prev,name;
;;;165      U32 fid = 0x8000;
0001da  f44f4800          MOV      r8,#0x8000
;;;166    
;;;167      for (bl = 0; bl < fcb->NumSect; bl++) {
0001de  2400              MOVS     r4,#0
0001e0  e048              B        |L1.628|
                  |L1.482|
;;;168        /* Search all allocated File Blocks for a given 'fname */
;;;169        adr = fs_adr_sig (bl, fcb);
0001e2  4629              MOV      r1,r5
0001e4  4620              MOV      r0,r4
0001e6  f7fffffe          BL       fs_adr_sig
;;;170        adr = fs_rd_sig (adr, &fa.end);
0001ea  a90a              ADD      r1,sp,#0x28
0001ec  f7fffffe          BL       fs_rd_sig
0001f0  4606              MOV      r6,r0
;;;171        if (fa.end != fcb->InitVal) {
0001f2  980a              LDR      r0,[sp,#0x28]
0001f4  68a9              LDR      r1,[r5,#8]
0001f6  4288              CMP      r0,r1
0001f8  d03b              BEQ      |L1.626|
;;;172          for (prev = 0; ; prev = fa.end) {
0001fa  2700              MOVS     r7,#0
;;;173            adr = fs_rd_alloc (adr, &fa);
;;;174            if (fa.fileID > 0x8000 && fa.fileID < 0xFFFF) {
0001fc  f46f4900          MVN      r9,#0x8000
000200  f6477afe          MOV      r10,#0x7ffe
000204  46bb              MOV      r11,r7                ;167
                  |L1.518|
000206  a90a              ADD      r1,sp,#0x28           ;173
000208  4630              MOV      r0,r6                 ;173
00020a  f7fffffe          BL       fs_rd_alloc
00020e  f8bd102c          LDRH     r1,[sp,#0x2c]
000212  4606              MOV      r6,r0                 ;173
000214  4449              ADD      r1,r1,r9
000216  4551              CMP      r1,r10
000218  d21d              BCS      |L1.598|
;;;175              /* Filename is 4-byte aligned. */
;;;176              name = ((DEVCONF *)fcb->DevCfg)[bl].bStart + prev;
00021a  68e8              LDR      r0,[r5,#0xc]
;;;177              name = (name + 3) & ~3;
;;;178              if (adr & 0x01) {
;;;179                /* Copy name for SPI Flash Drive. */
;;;180                fs_spi_ReadData (name, sizeof (buf), (U8 *)&buf);
;;;181              }
;;;182              else {
;;;183                fs_ReadData (name, sizeof (buf), (U8 *)&buf);
00021c  aa01              ADD      r2,sp,#4
00021e  f8500034          LDR      r0,[r0,r4,LSL #3]     ;176
000222  4438              ADD      r0,r0,r7              ;176
000224  1cc0              ADDS     r0,r0,#3              ;177
000226  07f1              LSLS     r1,r6,#31             ;178
000228  f0200003          BIC      r0,r0,#3              ;177
00022c  f04f0120          MOV      r1,#0x20
000230  d002              BEQ      |L1.568|
000232  f7fffffe          BL       fs_spi_ReadData
000236  e001              B        |L1.572|
                  |L1.568|
000238  f7fffffe          BL       fs_ReadData
                  |L1.572|
;;;184              }
;;;185              buf[31] = 0;
00023c  f88db023          STRB     r11,[sp,#0x23]
;;;186              if (fn_cmp (fname, (char *)&buf) == __TRUE) {
000240  a901              ADD      r1,sp,#4
000242  980f              LDR      r0,[sp,#0x3c]
000244  f7fffffe          BL       fn_cmp
000248  2801              CMP      r0,#1
;;;187                /* File with 'fname' has been found */
;;;188                fcb->fileID  = fa.fileID & 0x7FFF;
;;;189                fcb->_fblock = bl;
;;;190                return (0);
;;;191              }
;;;192              /* Search for the max fileID in use */
;;;193              if (fa.fileID > fid) {
00024a  f8bd002c          LDRH     r0,[sp,#0x2c]
00024e  d008              BEQ      |L1.610|
000250  4540              CMP      r0,r8
000252  d900              BLS      |L1.598|
;;;194                fid = fa.fileID;
000254  4680              MOV      r8,r0
                  |L1.598|
;;;195              }
;;;196            }
;;;197            if (fa.end == fcb->InitVal) break;
000256  980a              LDR      r0,[sp,#0x28]
000258  68a9              LDR      r1,[r5,#8]
00025a  4288              CMP      r0,r1
00025c  d009              BEQ      |L1.626|
00025e  4607              MOV      r7,r0                 ;172
000260  e7d1              B        |L1.518|
                  |L1.610|
000262  f3c0000e          UBFX     r0,r0,#0,#15          ;188
000266  8028              STRH     r0,[r5,#0]            ;188
000268  822c              STRH     r4,[r5,#0x10]         ;189
00026a  2000              MOVS     r0,#0                 ;190
                  |L1.620|
;;;198          }
;;;199        }
;;;200      }
;;;201      /* 'fid' is a nonzero value here */
;;;202      return (fid);
;;;203    }
00026c  b011              ADD      sp,sp,#0x44
00026e  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.626|
000272  1c64              ADDS     r4,r4,#1              ;167
                  |L1.628|
000274  88e8              LDRH     r0,[r5,#6]            ;167
000276  42a0              CMP      r0,r4                 ;167
000278  d8b3              BHI      |L1.482|
00027a  4640              MOV      r0,r8                 ;202
00027c  e7f6              B        |L1.620|
;;;204    
                          ENDP

                  fs_WriteBlock PROC
;;;344    
;;;345    BOOL fs_WriteBlock (U32 adr, void *buf, U32 cnt, IOB *fcb)  {
00027e  b510              PUSH     {r4,lr}
000280  460c              MOV      r4,r1
;;;346      int r = 1;
;;;347    
;;;348      /* 'adr' is always 4-byte aligned. */
;;;349      cnt = (cnt + 3) & ~3;
000282  1cd2              ADDS     r2,r2,#3
000284  f0220103          BIC      r1,r2,#3
;;;350      switch (fcb->drive) {
000288  791a              LDRB     r2,[r3,#4]
00028a  2a01              CMP      r2,#1
00028c  d004              BEQ      |L1.664|
00028e  2a02              CMP      r2,#2
000290  d006              BEQ      |L1.672|
000292  2a03              CMP      r2,#3
000294  d10c              BNE      |L1.688|
000296  e007              B        |L1.680|
                  |L1.664|
;;;351        case DRV_FLASH:
;;;352          r = fs_ProgramPage (adr, cnt, buf);
000298  4622              MOV      r2,r4
00029a  f7fffffe          BL       fs_ProgramPage
;;;353          break;
00029e  e006              B        |L1.686|
                  |L1.672|
;;;354        case DRV_SPI:
;;;355          r = fs_spi_ProgramPage (adr, cnt, buf);
0002a0  4622              MOV      r2,r4
0002a2  f7fffffe          BL       fs_spi_ProgramPage
;;;356          break;
0002a6  e002              B        |L1.686|
                  |L1.680|
;;;357        case DRV_RAM:
;;;358          r = fs_WriteData (adr, cnt, buf);
0002a8  4622              MOV      r2,r4
0002aa  f7fffffe          BL       fs_WriteData
                  |L1.686|
;;;359          break;
;;;360      }
;;;361      if (r) return (__FALSE);
0002ae  b108              CBZ      r0,|L1.692|
                  |L1.688|
0002b0  2000              MOVS     r0,#0
;;;362      return (__TRUE);
;;;363    }
0002b2  bd10              POP      {r4,pc}
                  |L1.692|
0002b4  2001              MOVS     r0,#1                 ;362
0002b6  bd10              POP      {r4,pc}
;;;364    
                          ENDP

                  fs_BlockFull PROC
;;;212    
;;;213    BOOL fs_BlockFull (IOB *fcb) {
0002b8  b51c              PUSH     {r2-r4,lr}
0002ba  4604              MOV      r4,r0
0002bc  e9d00105          LDRD     r0,r1,[r0,#0x14]
;;;214      FALLOC alloc;
;;;215    
;;;216      if ((fcb->_ftop - sizeof (FALLOC)) > fcb->_fbot) {
0002c0  3908              SUBS     r1,r1,#8
0002c2  4281              CMP      r1,r0
0002c4  d901              BLS      |L1.714|
;;;217        /* Enough space in current Flash Block */
;;;218        return (__FALSE);
0002c6  2000              MOVS     r0,#0
;;;219      }
;;;220      /* No more free space, write File Allocation Information */
;;;221      alloc.end    = fcb->_fbot;
;;;222      alloc.fileID = fcb->fileID;
;;;223      alloc.index  = fcb->_fidx++;
;;;224      fs_WriteBlock (((DEVCONF *)fcb->DevCfg)[fcb->_fblock].bStart + fcb->_ftop,
;;;225                     &alloc, sizeof (FALLOC), fcb);
;;;226      /* Mark this Flash Block as full */
;;;227      alloc.end = fcb->InitVal ^ BlockFULL;
;;;228      fs_WriteBlock (((DEVCONF *)fcb->DevCfg)[fcb->_fblock].bEnd, &alloc, 4, fcb);
;;;229      return (__TRUE);
;;;230    }
0002c8  bd1c              POP      {r2-r4,pc}
                  |L1.714|
0002ca  9000              STR      r0,[sp,#0]            ;222
0002cc  8820              LDRH     r0,[r4,#0]            ;222
0002ce  f8ad0004          STRH     r0,[sp,#4]            ;222
0002d2  8a60              LDRH     r0,[r4,#0x12]         ;223
0002d4  f8ad0006          STRH     r0,[sp,#6]            ;223
0002d8  8a60              LDRH     r0,[r4,#0x12]         ;223
0002da  4623              MOV      r3,r4                 ;224
0002dc  1c40              ADDS     r0,r0,#1              ;223
0002de  8260              STRH     r0,[r4,#0x12]         ;223
0002e0  8a21              LDRH     r1,[r4,#0x10]         ;224
0002e2  68e0              LDR      r0,[r4,#0xc]          ;224
0002e4  2208              MOVS     r2,#8                 ;224
0002e6  f8500031          LDR      r0,[r0,r1,LSL #3]     ;224
0002ea  69a1              LDR      r1,[r4,#0x18]         ;224
0002ec  4408              ADD      r0,r0,r1              ;224
0002ee  4669              MOV      r1,sp                 ;224
0002f0  f7fffffe          BL       fs_WriteBlock
0002f4  68a0              LDR      r0,[r4,#8]            ;227
0002f6  2204              MOVS     r2,#4                 ;228
0002f8  f08000ff          EOR      r0,r0,#0xff           ;227
0002fc  9000              STR      r0,[sp,#0]            ;228
0002fe  8a21              LDRH     r1,[r4,#0x10]         ;228
000300  68e0              LDR      r0,[r4,#0xc]          ;228
000302  eb0201c1          ADD      r1,r2,r1,LSL #3       ;228
000306  4623              MOV      r3,r4                 ;228
000308  5840              LDR      r0,[r0,r1]            ;228
00030a  4669              MOV      r1,sp                 ;228
00030c  f7fffffe          BL       fs_WriteBlock
000310  2001              MOVS     r0,#1                 ;229
000312  bd1c              POP      {r2-r4,pc}
;;;231    
                          ENDP

                  fs_AllocBlock PROC
;;;239    
;;;240    BOOL fs_AllocBlock (IOB *fcb) {
000314  b5f8              PUSH     {r3-r7,lr}
000316  4604              MOV      r4,r0
;;;241      U32 i,bl,adr,bflag;
;;;242    
;;;243      bl = fcb->_fblock;
000318  8a05              LDRH     r5,[r0,#0x10]
;;;244      for (i = 0; i < fcb->NumSect; i++) {
00031a  2600              MOVS     r6,#0
00031c  e046              B        |L1.940|
                  |L1.798|
;;;245        adr = fs_adr_sig (bl, fcb);
00031e  4621              MOV      r1,r4
000320  4628              MOV      r0,r5
000322  f7fffffe          BL       fs_adr_sig
;;;246        adr = fs_rd_sig (adr, &bflag);
000326  4669              MOV      r1,sp
000328  f7fffffe          BL       fs_rd_sig
00032c  4607              MOV      r7,r0
;;;247        if (bflag == fcb->InitVal) {
00032e  68a0              LDR      r0,[r4,#8]
000330  9900              LDR      r1,[sp,#0]
000332  4288              CMP      r0,r1
000334  d114              BNE      |L1.864|
;;;248          /* Free Flash Block allocated */
;;;249          fcb->_fblock = bl;
000336  8225              STRH     r5,[r4,#0x10]
;;;250          fcb->_fbot = 0;
000338  2000              MOVS     r0,#0
;;;251          fcb->_ftop = (adr & ~1) - ((DEVCONF *)fcb->DevCfg)[bl].bStart;
00033a  6160              STR      r0,[r4,#0x14]
00033c  68e0              LDR      r0,[r4,#0xc]
;;;252          bflag ^= BlockUSED;
;;;253          fs_WriteBlock ((adr & ~1) + 8, &bflag, 4, fcb);
00033e  4623              MOV      r3,r4
000340  2204              MOVS     r2,#4
000342  f8501035          LDR      r1,[r0,r5,LSL #3]     ;251
000346  f0270001          BIC      r0,r7,#1              ;251
00034a  1a41              SUBS     r1,r0,r1              ;251
00034c  61a1              STR      r1,[r4,#0x18]         ;252
00034e  9900              LDR      r1,[sp,#0]            ;252
000350  3008              ADDS     r0,r0,#8
000352  f081010f          EOR      r1,r1,#0xf            ;252
000356  9100              STR      r1,[sp,#0]
000358  4669              MOV      r1,sp
00035a  f7fffffe          BL       fs_WriteBlock
;;;254          return (__TRUE);
00035e  e011              B        |L1.900|
                  |L1.864|
;;;255        }
;;;256        if ((bflag ^ BlockUSED) == fcb->InitVal) {
000360  f081010f          EOR      r1,r1,#0xf
000364  4281              CMP      r1,r0
000366  d11b              BNE      |L1.928|
;;;257          /* Check if a file already opened for writing in this Block */
;;;258          if (fs_check_fwopen (bl, fcb) == __FALSE) {
000368  4621              MOV      r1,r4
00036a  4628              MOV      r0,r5
00036c  f7fffffe          BL       fs_check_fwopen
000370  b9b0              CBNZ     r0,|L1.928|
;;;259            /* Try already used Flash Block and check for free space */
;;;260            if (fs_get_freeMem (bl, fcb) > 0) {
000372  4621              MOV      r1,r4
000374  4628              MOV      r0,r5
000376  f7fffffe          BL       fs_get_freeMem
00037a  b128              CBZ      r0,|L1.904|
;;;261              fcb->_fblock = bl; 
00037c  8225              STRH     r5,[r4,#0x10]
;;;262              fs_mark_freeMem (fcb);
00037e  4620              MOV      r0,r4
000380  f7fffffe          BL       fs_mark_freeMem
                  |L1.900|
;;;263              return (__TRUE);
000384  2001              MOVS     r0,#1
;;;264            }
;;;265            bflag = fcb->InitVal ^ BlockFULL;
;;;266            fs_WriteBlock ((adr & ~1) + 8, &bflag, 4, fcb);
;;;267          }
;;;268        }
;;;269        if (++bl == fcb->NumSect) {
;;;270          bl = 0;
;;;271        }
;;;272      }
;;;273      return (__FALSE);
;;;274    }
000386  bdf8              POP      {r3-r7,pc}
                  |L1.904|
000388  68a0              LDR      r0,[r4,#8]            ;265
00038a  4623              MOV      r3,r4                 ;266
00038c  f08000ff          EOR      r0,r0,#0xff           ;265
000390  9000              STR      r0,[sp,#0]            ;266
000392  f0270001          BIC      r0,r7,#1              ;266
000396  3008              ADDS     r0,r0,#8              ;266
000398  2204              MOVS     r2,#4                 ;266
00039a  4669              MOV      r1,sp                 ;266
00039c  f7fffffe          BL       fs_WriteBlock
                  |L1.928|
0003a0  88e0              LDRH     r0,[r4,#6]            ;269
0003a2  1c6d              ADDS     r5,r5,#1              ;269
0003a4  4285              CMP      r5,r0                 ;269
0003a6  d100              BNE      |L1.938|
0003a8  2500              MOVS     r5,#0                 ;270
                  |L1.938|
0003aa  1c76              ADDS     r6,r6,#1              ;244
                  |L1.940|
0003ac  88e0              LDRH     r0,[r4,#6]            ;244
0003ae  42b0              CMP      r0,r6                 ;244
0003b0  d8b5              BHI      |L1.798|
0003b2  2000              MOVS     r0,#0                 ;273
0003b4  bdf8              POP      {r3-r7,pc}
;;;275    
                          ENDP

                  fs_BlockInvalid PROC
;;;283    
;;;284    BOOL fs_BlockInvalid (U32 block, IOB *fcb)  {
0003b6  b57c              PUSH     {r2-r6,lr}
0003b8  460c              MOV      r4,r1
;;;285      FALLOC fa;
;;;286      U32 adr;
;;;287      U16 invalid;
;;;288    
;;;289      invalid = ~fcb->InitVal;
0003ba  6889              LDR      r1,[r1,#8]
0003bc  43c9              MVNS     r1,r1
0003be  b28d              UXTH     r5,r1
;;;290      /* Check if this Flash Block is all invalided */
;;;291      adr = fs_adr_sig (block, fcb) - 8;
0003c0  4621              MOV      r1,r4
0003c2  f7fffffe          BL       fs_adr_sig
0003c6  3808              SUBS     r0,r0,#8
                  |L1.968|
;;;292      for (;;) {
;;;293        adr = fs_rd_alloc (adr, &fa);
0003c8  4669              MOV      r1,sp
0003ca  f7fffffe          BL       fs_rd_alloc
;;;294        if (fa.end == fcb->InitVal) break;
0003ce  9900              LDR      r1,[sp,#0]
0003d0  68a2              LDR      r2,[r4,#8]
0003d2  4291              CMP      r1,r2
0003d4  d005              BEQ      |L1.994|
;;;295        if (fa.fileID != invalid) {
0003d6  f8bd1004          LDRH     r1,[sp,#4]
0003da  42a9              CMP      r1,r5
0003dc  d0f4              BEQ      |L1.968|
;;;296          /* A valid file block found */
;;;297          return (__FALSE);
0003de  2000              MOVS     r0,#0
;;;298        }
;;;299      }
;;;300      return (__TRUE);
;;;301    }
0003e0  bd7c              POP      {r2-r6,pc}
                  |L1.994|
0003e2  2001              MOVS     r0,#1                 ;300
0003e4  bd7c              POP      {r2-r6,pc}
;;;302    
                          ENDP

                  fs_InitBlock PROC
;;;311    
;;;312    BOOL fs_InitBlock (U32 block, IOB *fcb)  {
0003e6  b510              PUSH     {r4,lr}
;;;313      U32 adr,enda;
;;;314    
;;;315      switch (fcb->drive) {
0003e8  7909              LDRB     r1,[r1,#4]
0003ea  2901              CMP      r1,#1
0003ec  d004              BEQ      |L1.1016|
0003ee  2902              CMP      r1,#2
0003f0  d008              BEQ      |L1.1028|
0003f2  2903              CMP      r1,#3
0003f4  d117              BNE      |L1.1062|
0003f6  e00b              B        |L1.1040|
                  |L1.1016|
;;;316        case DRV_FLASH:
;;;317          adr = FlashDev[block].bStart;
0003f8  4915              LDR      r1,|L1.1104|
0003fa  f8510030          LDR      r0,[r1,r0,LSL #3]
;;;318          fs_EraseSector (adr);
0003fe  f7fffffe          BL       fs_EraseSector
;;;319          break;
000402  e010              B        |L1.1062|
                  |L1.1028|
;;;320        case DRV_SPI:
;;;321          adr = SpiDev[block].bStart;
000404  4913              LDR      r1,|L1.1108|
000406  f8510030          LDR      r0,[r1,r0,LSL #3]
;;;322          fs_spi_EraseSector (adr);
00040a  f7fffffe          BL       fs_spi_EraseSector
;;;323          break;
00040e  e00a              B        |L1.1062|
                  |L1.1040|
;;;324        case DRV_RAM:
;;;325          enda = RamDev[block].bEnd;
000410  4a11              LDR      r2,|L1.1112|
000412  eb0201c0          ADD      r1,r2,r0,LSL #3
;;;326          for (adr = RamDev[block].bStart; adr <= enda; adr += 4) {
000416  f8520030          LDR      r0,[r2,r0,LSL #3]
00041a  6849              LDR      r1,[r1,#4]            ;325
;;;327            MVAR (U32, adr) = 0x00;
00041c  2200              MOVS     r2,#0
00041e  e000              B        |L1.1058|
                  |L1.1056|
000420  c004              STM      r0!,{r2}
                  |L1.1058|
000422  4288              CMP      r0,r1                 ;326
000424  d9fc              BLS      |L1.1056|
                  |L1.1062|
;;;328          }
;;;329          break;
;;;330      }
;;;331      return (__TRUE);
000426  2001              MOVS     r0,#1
;;;332    }
000428  bd10              POP      {r4,pc}
;;;333    
                          ENDP

                  fs_ReadBlock PROC
;;;374    
;;;375    BOOL fs_ReadBlock (U32 adr, void *buf, U32 cnt, IOB *fcb)  {
00042a  b510              PUSH     {r4,lr}
00042c  460c              MOV      r4,r1
00042e  4611              MOV      r1,r2
;;;376    
;;;377      /* Both 'adr' and 'buf' may be unaligned. */
;;;378      if (fcb->drive == DRV_SPI) {
000430  791a              LDRB     r2,[r3,#4]
000432  2a02              CMP      r2,#2
;;;379        /* Read from SPI Flash. */
;;;380        fs_spi_ReadData (adr, cnt, buf);
;;;381        return (__TRUE);
;;;382      }
;;;383    
;;;384      /* Read from RAM or Parallel Flash */
;;;385      fs_ReadData (adr, cnt, buf);
000434  4622              MOV      r2,r4
000436  d003              BEQ      |L1.1088|
000438  f7fffffe          BL       fs_ReadData
                  |L1.1084|
;;;386      return (__TRUE);
00043c  2001              MOVS     r0,#1
;;;387    }
00043e  bd10              POP      {r4,pc}
                  |L1.1088|
000440  f7fffffe          BL       fs_spi_ReadData
000444  e7fa              B        |L1.1084|
;;;388    
                          ENDP

000446  0000              DCW      0x0000
                  |L1.1096|
                          DCD      _iob
                  |L1.1100|
                          DCD      _NFILE
                  |L1.1104|
                          DCD      FlashDev
                  |L1.1108|
                          DCD      SpiDev
                  |L1.1112|
                          DCD      RamDev

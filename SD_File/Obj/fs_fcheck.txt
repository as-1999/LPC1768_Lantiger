; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--debug -c --asm --interleave -o.\Obj\fs_fcheck.o --depend=.\Obj\fs_fcheck.d --cpu=Cortex-M3 --apcs=interwork -O3 -I.\FlashFS -Id:\Keil\ARM\INC -Id:\Keil\ARM\INC\NXP\LPC17xx --omf_browse=.\Obj\fs_fcheck.crf FlashFS\fs_fcheck.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  fcheck PROC
;;;15     
;;;16     int fcheck (const char *drive) {
000000  e92d41fc          PUSH     {r2-r8,lr}
000004  4605              MOV      r5,r0
;;;17       /* Analyse the FlashFS and check for allocation errors. */
;;;18       FALLOC fa;
;;;19       IOB *fcb;
;;;20       int handle;
;;;21       U32 bl,adr,prev,sa;
;;;22     
;;;23       START_LOCK (int);
000006  482b              LDR      r0,|L1.180|
000008  f7fffffe          BL       _mutex_acquire
;;;24     
;;;25       /* Find an unused _iob structure. */
;;;26       if ((handle = fs_find_iob ()) == EOF) {
00000c  f7fffffe          BL       fs_find_iob
000010  1c41              ADDS     r1,r0,#1
000012  d03f              BEQ      |L1.148|
;;;27         RETURN (1);
;;;28       }
;;;29       fcb = &_iob[handle];
000014  eb000180          ADD      r1,r0,r0,LSL #2
000018  eb0100c0          ADD      r0,r1,r0,LSL #3
00001c  4926              LDR      r1,|L1.184|
00001e  eb010480          ADD      r4,r1,r0,LSL #2
;;;30       /* Get the drive index. */
;;;31       fcb->drive = fs_get_drive (drive);
000022  4628              MOV      r0,r5
000024  f7fffffe          BL       fs_get_drive
000028  f01000ff          ANDS     r0,r0,#0xff
00002c  7120              STRB     r0,[r4,#4]
;;;32       if (fcb->drive == DRV_NONE && *drive == 0) {
00002e  d104              BNE      |L1.58|
000030  7828              LDRB     r0,[r5,#0]
000032  b928              CBNZ     r0,|L1.64|
;;;33         /* Empty string provided for a drive name. */
;;;34         fcb->drive = _DEF_DRIVE;
000034  4821              LDR      r0,|L1.188|
000036  8800              LDRH     r0,[r0,#0]  ; _DEF_DRIVE
000038  7120              STRB     r0,[r4,#4]
                  |L1.58|
;;;35       }
;;;36       if (fcb->drive == DRV_MCARD) {
00003a  b2c0              UXTB     r0,r0
00003c  2804              CMP      r0,#4
00003e  d029              BEQ      |L1.148|
                  |L1.64|
;;;37         /* Memory Card currently not supported. */
;;;38         RETURN (1);
;;;39       }
;;;40       /* Set drive parameters. */
;;;41       if (fs_set_params (fcb) == __FALSE) {
000040  4620              MOV      r0,r4
000042  f7fffffe          BL       fs_set_params
000046  b328              CBZ      r0,|L1.148|
;;;42         RETURN (1);
;;;43       }
;;;44     
;;;45       for (bl = 0; bl < fcb->NumSect; bl++) {
000048  2500              MOVS     r5,#0
;;;46         /* Check all File Blocks for invalid FID and check file pointers for */
;;;47         /* reasonable values in ascending order.                             */
;;;48         adr = fs_adr_sig (bl, fcb);
;;;49         adr = fs_rd_sig (adr, &fa.end);
;;;50         if (fa.end != fcb->InitVal) {
;;;51           sa = ((DEVCONF *)fcb->DevCfg)[bl].bStart;
;;;52           for (prev = 0; ; prev = fa.end) {
;;;53             adr = fs_rd_alloc (adr, &fa);
;;;54             if (fa.end == fcb->InitVal) {
;;;55               /* End of Allocation info. */
;;;56               break;
;;;57             }
;;;58             if (fa.fileID == 0x8000) {
00004a  f44f4700          MOV      r7,#0x8000
00004e  e026              B        |L1.158|
                  |L1.80|
000050  4621              MOV      r1,r4                 ;48
000052  4628              MOV      r0,r5                 ;48
000054  f7fffffe          BL       fs_adr_sig
000058  4669              MOV      r1,sp                 ;49
00005a  f7fffffe          BL       fs_rd_sig
00005e  9900              LDR      r1,[sp,#0]            ;50
000060  68a2              LDR      r2,[r4,#8]            ;50
000062  4291              CMP      r1,r2                 ;50
000064  d01a              BEQ      |L1.156|
000066  68e1              LDR      r1,[r4,#0xc]          ;51
000068  2600              MOVS     r6,#0                 ;52
00006a  f8518035          LDR      r8,[r1,r5,LSL #3]     ;51
                  |L1.110|
00006e  4669              MOV      r1,sp                 ;53
000070  f7fffffe          BL       fs_rd_alloc
000074  9900              LDR      r1,[sp,#0]            ;54
000076  68a2              LDR      r2,[r4,#8]            ;54
000078  4291              CMP      r1,r2                 ;54
00007a  d00f              BEQ      |L1.156|
00007c  f8bd1004          LDRH     r1,[sp,#4]
000080  42b9              CMP      r1,r7
000082  d007              BEQ      |L1.148|
;;;59               /* Error, not existing file ID. */
;;;60               RETURN (1);
;;;61             }
;;;62             if (fa.end < prev) {
000084  9900              LDR      r1,[sp,#0]
000086  42b1              CMP      r1,r6
000088  d304              BCC      |L1.148|
;;;63               /* Error, not ascending allocation pointers. */
;;;64               RETURN (1);
;;;65             }
;;;66             if ((sa + fa.end) > (adr & ~1)) {
00008a  4441              ADD      r1,r1,r8
00008c  f0200201          BIC      r2,r0,#1
000090  4291              CMP      r1,r2
000092  d901              BLS      |L1.152|
                  |L1.148|
;;;67               /* Error, overlapping file allocation record. */
;;;68               RETURN (1);
000094  2401              MOVS     r4,#1
000096  e006              B        |L1.166|
                  |L1.152|
000098  9e00              LDR      r6,[sp,#0]            ;52
00009a  e7e8              B        |L1.110|
                  |L1.156|
00009c  1c6d              ADDS     r5,r5,#1              ;45
                  |L1.158|
00009e  88e0              LDRH     r0,[r4,#6]            ;45
0000a0  42a8              CMP      r0,r5                 ;45
0000a2  d8d5              BHI      |L1.80|
;;;69             }
;;;70           }
;;;71         }
;;;72       }
;;;73       /* OK, file integrity passed. */
;;;74       RETURN (0);
0000a4  2400              MOVS     r4,#0
                  |L1.166|
;;;75     
;;;76       END_LOCK;
0000a6  4803              LDR      r0,|L1.180|
0000a8  f7fffffe          BL       _mutex_release
0000ac  4620              MOV      r0,r4
;;;77     }
0000ae  e8bd81fc          POP      {r2-r8,pc}
;;;78     
                          ENDP

0000b2  0000              DCW      0x0000
                  |L1.180|
                          DCD      _stream_list_lock
                  |L1.184|
                          DCD      _iob
                  |L1.188|
                          DCD      _DEF_DRIVE
